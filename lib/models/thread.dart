import 'package:dart_mappable/dart_mappable.dart';
import 'package:isar_community/isar.dart';

part 'thread.mapper.dart';
part 'thread.g.dart';

@MappableClass()
@Collection()
class Thread with ThreadMappable {
  final Id id;
  final String title;
  final String autoGeneratedTitle;
  final String groupName;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime lastAccessedAt;
  final bool isArchived;
  final bool isPinned;
  final List<String> messageIds;
  final int messageCount;
  final DateTime? lastMessageAt;
  final List<String> tags;

  const Thread({
    this.id = Isar.autoIncrement,
    required this.title,
    this.autoGeneratedTitle = '',
    this.groupName = 'General',
    required this.createdAt,
    required this.updatedAt,
    required this.lastAccessedAt,
    this.isArchived = false,
    this.isPinned = false,
    this.messageIds = const [],
    this.messageCount = 0,
    this.lastMessageAt,
    this.tags = const [],
  });

  /// Create a new thread with auto-generated title
  factory Thread.create({
    String? title,
    String? groupName,
  }) {
    final now = DateTime.now();
    return Thread(
      title: title ?? '',
      groupName: groupName ?? 'General',
      createdAt: now,
      updatedAt: now,
      lastAccessedAt: now,
    );
  }

  /// Generate thread title from first message
  Thread withGeneratedTitle(String firstMessageContent) {
    final words = firstMessageContent.split(' ').take(4).join(' ');
    final generatedTitle = words.isNotEmpty
        ? '${words[0].toUpperCase()}${words.substring(1)}'
        : 'New Thread';

    return copyWith(
      title: title.isEmpty ? generatedTitle : title,
      autoGeneratedTitle: generatedTitle,
      updatedAt: DateTime.now(),
    );
  }

  /// Add a message to the thread
  Thread addMessage(String messageId) {
    final updatedMessageIds = [...messageIds, messageId];
    return copyWith(
      messageIds: updatedMessageIds,
      messageCount: updatedMessageIds.length,
      updatedAt: DateTime.now(),
      lastAccessedAt: DateTime.now(),
      lastMessageAt: DateTime.now(),
    );
  }

  /// Remove a message from the thread
  Thread removeMessage(String messageId) {
    final updatedMessageIds =
        messageIds.where((id) => id != messageId).toList();
    return copyWith(
      messageIds: updatedMessageIds,
      messageCount: updatedMessageIds.length,
      updatedAt: DateTime.now(),
    );
  }

  /// Update thread access time
  Thread markAsAccessed() {
    return copyWith(
      lastAccessedAt: DateTime.now(),
    );
  }

  /// Update thread group
  Thread updateGroup(String newGroupName) {
    return copyWith(
      groupName: newGroupName,
      updatedAt: DateTime.now(),
    );
  }

  /// Toggle pinned status
  Thread togglePin() {
    return copyWith(
      isPinned: !isPinned,
      updatedAt: DateTime.now(),
    );
  }

  /// Add tag to thread
  Thread addTag(String tag) {
    if (tags.contains(tag)) return this;

    return copyWith(
      tags: [...tags, tag],
      updatedAt: DateTime.now(),
    );
  }

  /// Remove tag from thread
  Thread removeTag(String tag) {
    return copyWith(
      tags: tags.where((t) => t != tag).toList(),
      updatedAt: DateTime.now(),
    );
  }

  /// Get display title (prefer user-set title, fall back to auto-generated)
  String get displayTitle {
    if (title.isNotEmpty && title != autoGeneratedTitle) {
      return title;
    }
    return autoGeneratedTitle.isNotEmpty ? autoGeneratedTitle : 'New Thread';
  }

  /// Check if thread is empty
  bool get isEmpty {
    return messageIds.isEmpty;
  }
}
